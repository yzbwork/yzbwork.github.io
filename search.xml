<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jenkins持续化集成，自动打包，OTA分发]]></title>
    <url>%2Fpost%2Ff7f1ad1.html</url>
    <content type="text"><![CDATA[整个流程是Jenkins设置自动定时运行脚本，打包生成ipa文件和plist文件，成功之后，自动发送钉钉消息给测试人员，测试人员打开下载地址，OTA安装。 环境：macOS10.12.5，Xcode 8.3.3，ruby2.4.0，java1.8.0 搭建Jenkins自动打包自动打包用的是一个自动打包的脚本：PPAutoPackageScript ，GitHub地址：https://github.com/jkpang/PPAutoPackageScriptPPAutoPackageScript在本地的用法见GitHub，作者写了详细的使用方法。整体来说没有难度，按步骤来就行。先把脚本里面需要自己修改的部分，修改完成之后，测试打包没问题，再继续下一步。注意：Xcode证书管理部分不要设置自动管理，否则会报错 OTA分发部分OTA分发，我是在本地搭建的服务器，目前OTA分发只支持Https，所以需要OpenSSL自制证书。后面有具体方法，先搭建服务器。 启动服务器macOS 自带apache服务，所以终端输入 sudo apachectl start ，浏览器输入http://127.0.0.1，如果出现It Works!，OK，服务器启动成功。 修改配置服务器默认目录“/Library/WebServer/Documents/“，编辑“/etc/apache2/httpd.conf “，找到 DocumentRoot “/Library/WebServer/Documents” 改为你想作为服务器根目录的路径。其他修改如下图： OpenSSL自制证书生成服务器的私钥mkdir /private/etc/apache2/ssl cd /private/etc/apache2/ssl sudo openssl genrsa -out server.key 1024 生成签署申请sudo openssl req -new -key server.key -out server.csr (需要输入多个项目，其中Common Name为服务器的域名或IP) 生成CA私钥sudo openssl genrsa -out ca.key 1024 用CA的私钥产生CA的自签署证书sudo openssl req -new -x509 -days 365 -key ca.key -out ca.crt 创建demoCAsudo mkdir demoCA cd demoCA mkdir newcerts 创建文件index.txt和serial，serial内容为01，index.txt为空(index.txt必须为空，否则后报错)返回ssl文件夹 sudo openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key 目前为止生成了server.crt，server.key，ca.crt文件，位置分别为“/private/etc/apache2/ssl/server.crt”，“/private/etc/apache2/ssl/server.key”，ca.crt 放在文件根目录(也就是前面DocumentRoot文件夹中)。 配置服务器的SSL服务编辑/private/etc/apache2/httpd.conf，去掉下面几个项目的注释(去掉前面的‘#’) LoadModule ssl_module libexec/apache2/mod_ssl.so LoadModule socache_shmcb_module libexec/apache2/mod_socache_shmcb.so Include /private/etc/apache2/extra/httpd-ssl.conf Include /private/etc/apache2/extra/httpd-vhosts.conf 编辑/private/etc/apache2/extra/httpd-ssl.conf修改下面两项的路径，改为刚才ssl证书存放的路径，如下： SSLCertificateFile &quot;/private/etc/apache2/ssl/server.crt&quot; SSLCertificateKeyFile &quot;/private/etc/apache2/ssl/server.key&quot; 编辑/private/etc/apache2/extra/httpd-vhosts.conf文件末尾添加： &lt;VirtualHost *:443&gt; SSLEngine on SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+eNULL SSLCertificateFile /private/etc/apache2/ssl/server.crt SSLCertificateKeyFile /private/etc/apache2/ssl/server.key ServerName 192.168.1.35(服务器的IP) DocumentRoot &quot;同上面的DocumentRoot路径&quot; &lt;/VirtualHost&gt; 添加完之后 sudo apachectl configtest 有问题按照提示开启相关服务，没问题的话重启服务器 sudo apachectl restart 到此就可以https访问服务器了。 编写OTA安装需要的plist文件，以及服务器页面在服务器的根目录(DocumentRoot目录)下，新建plist文件，命名为manifest.plist文件根据自己的情况修改，两个图片地址可要可不要，文件模版如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://192.168.1.35/pay.ipa&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://192.168.1.35/pay57.png&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://192.168.1.35/pay512.png&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;打包的bundleidentifier&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;app版本号&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;app名称&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; plist文件创建后，再新建index.html，要包含app的下载地址和SSL证书的下载地址，其他部分自己写，下载地址如下： &lt;a href=&quot;itms-services://?action=download-manifest&amp;url=https://192.168.1.35/manifest.plist&quot;&gt;appName&lt;/a&gt; &lt;a href=&quot;http://192.168.1.35/ca.crt&quot;&gt;安装SSL证书&lt;/a&gt; 到目前为止，所有电脑上的设置结束了，可以把第二步测试生成的adhoc版app和ca.crt 文件，放在服务区根目录下，测试一下OTA安装是否可用。 测试：手机跟电脑在同一个局域网内，手机访问服务器的页面，先点击安装SSL证书，安装证书，然后在设置——&gt;通用——&gt;描述文件，设置刚才安装的证书为信任。接下来最重要的一步，设置——&gt;通用——&gt;关于本机，最下面的证书信任设置，再次设置信任。这个时候再返回网页才能下载安装app。否则会出现”无法连接***”。测试没有问题，进行下一步。 所有流程串起来这一步需要把Jenkins和OTA分发服务器，钉钉连通，整个流程走通PPAutoPackageScript 脚本除了作者建议修改的部分外，我们还需要根据需求稍作修改。首先，修改输出ipa路径，改为服务器的根目录，如图：这样输出的ipa文件直接就在根目录，不需要再复制ipa文件到根目录下，路径要和plist文件里的下载路径一样。但是还有一个问题，plist文件中，bundle-identifier还好，一个项目中基本上不会修改，但是版本号会经常变。我的解决方法比较笨，直接重新生成plist文件，在脚本ipa文件输出成功之后打开输出目录之前（open $export_path，这一步的前面）添加如下代码，仅供参考： cd $export_path cat &lt;&lt; EOF &gt; manifest.plist &lt;...&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://192.168.1.35/App/v$bundle_version/${ipa_name}.ipa&lt;/string&gt; &lt;...&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;打包的bundleidentifier&lt;/string&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;$bundle_version&lt;/string&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;$scheme_name&lt;/string&gt; &lt;...&gt; EOF &lt;…&gt;部分跟前面的plist模版一样，不再重复，可以直接复制模版修改。这里的下载路径包括脚本里的export_path也即输出路径，根据自己的需求修改，如果是直接生成在根目录下，https://192.168.1.35/${ipa_name}.ipa这样写，生成的新ipa文件会覆盖旧的。我这里是让它每次根据版本号输出到不同的文件夹。 脚本文件修改完毕之后，登陆Jenkins，进入之前建的项目中，点击配置，在钉钉通知消息这一步的前面增加构建步骤，如图：第一行是打开脚本所在的位置，第二行运行脚本。OK，保存，返回项目点击立即构建。测试没有问题之后，再在配置里面设置定时构建，语法点击输入框后面的问号有参考。以上就是整个全部流程，自己正在用，网上好多步骤不完整或是比较老，出现错误参考每一步的 注意 部分，特别要注意iOS10 出现无法连接到***的错误！！！。有错误的地方请指正，互相交流。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Jenkins</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins搭建]]></title>
    <url>%2Fpost%2Fd6658693.html</url>
    <content type="text"><![CDATA[Jenkins搭建下载对应的安装包安装即可，或者下载war包，终端运行。war包运行之后，终端会有一串稍微长的字符串，复制下来，这是Jenkins第一次运行时的密码。Jenkins运行安装完推荐的插件之后，新建，选择第一个，保存，后面再配置。 打开钉钉添加机器人，选择自定义 回到jenkins 刚刚新建的项目，选择配置，跟钉钉连通时，以下方法二选一即可：方法一：如果下载的插件是 DingDing[钉钉]Plugin ， 在构建后操作里面，选择钉钉通知器，如图：注意：Jenkins URL地址后面要加“／”。方法二：如果下载的插件是 HTTP Request Plugin，在构建增加构建步骤时选择HTTP Requestcontent-type要选utf-8，body按照钉钉的消息格式设置，机器人的配置说明里面有格式。 保存之后，点击立即构建，钉钉机器人就可以发出消息了方法一对应的消息比较单调，方法二可以设置多种格式。参考：其它格式的参考钉钉机器人设置说明]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Jenkins</tag>
        <tag>钉钉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 安装、使用]]></title>
    <url>%2Fpost%2Ffaa5897a.html</url>
    <content type="text"><![CDATA[安装ruby下载安装CocoaPods需要Ruby环境, Mac OS本身自带Ruby，但还是更新一下保险 查看下当前ruby版本：打开终端输入 ruby -v更新ruby终端输入如下命令（把Ruby镜像指向taobao镜像，避免被墙） gem sources --remove https://rubygems.org/ gem sources -a https://ruby.taobao.org/ （已停止，更换为下面的） gem sources -a https://gems.ruby-china.com gem sources -l （查看当前镜像） 如图： 安装sudo gem install cocoapods 成功会有“gem installed”的提示 执行pod install 命令出现Setting up CocoaPods master repo，说明Cocoapods在将它的信息下载到 ~/.cocoapods里，cd 到该目录里，用du -sh *命令来查看文件大小，每隔几分钟查看一次，这个目录最终大小是100多M，就是完成了。 可能出现的错误在运行 “sudo gem install cocoapods” 的时候出现问题：ERROR: While executing gem … (Errno::EPERM)Operation not permitted - /usr/bin/fuzzy_match 则可以改为： sudo gem install -n /usr/local/bin cocoapods 使用在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：$ vim Podfile然后在Podfile文件中输入以下文字：platform :ios, ‘7.0’pod “AFNetworking”, “~&gt; 2.0”注意，这段文字可以在AFNetworking的github页面找到。这两句文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 7.0, 要下载的AFNetworking版本是2.0。 然后保存退出。vim环境下，保存退出命令是：:wq 这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。注意，Podfile文件应该和你的工程文件.xcodeproj在同一个目录下。 这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令：$ pod install 编译运行一个包含CocoPods类库的项目 打开终端，进入所在目录，也就是和Podfile在同一目录下，输入pod update过一会儿（取决于网络状况），终端提示。原文件夹多了一个xxxx.xcworkspace，点击运行该文件即可编译。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
